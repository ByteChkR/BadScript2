
let Native = Runtime.Native;

@|
	Asserts that the specified object is a String
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsString(obj)
{
	if(obj == null || !Native.IsString(obj)) throw "Expected String";
}

@|
	Asserts that the specified object is a Boolean
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsBoolean(obj)
{
	if(obj == null || !Native.IsBoolean(obj)) throw "Expected Boolean";
}


@|
	Asserts that the specified object is a Number
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsNumber(obj)
{
	if(obj == null || !Native.IsNumber(obj)) throw "Expected Number";
}


@|
	Asserts that the specified object is an Array
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsArray(obj)
{
	if(obj == null || !Native.IsArray(obj)) throw "Expected Array";
}

@|
	Asserts that the specified object is a Table
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsTable(obj)
{
	if(obj == null || !Native.IsTable(obj)) throw "Expected Table";
}

@|
	Asserts that the specified object is a Function
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsFunction(obj)
{
	if(obj == null || !Native.IsFunction(obj)) throw "Expected Function";
}


@|
	Asserts that the specified object is an Enumerable
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsEnumerable(obj)
{
	if(obj == null || !Native.IsEnumerable(obj)) throw "Expected Enumerable";
}


@|
	Asserts that the specified object is an Enumerator
	|PARAM obj: object that will be tested
	|RET: void(throws if assertion fails)
|@
function IsEnumerator(obj)
{
	if(obj == null || !Native.IsEnumerator(obj)) throw "Expected Enumerator";
}

const Assert = {
	IsString: IsString,
	IsBoolean: IsBoolean,
	IsNumber: IsNumber,
	IsArray: IsArray,
	IsTable: IsTable,
	IsFunction: IsFunction,
	IsEnumerator: IsEnumerator,
	IsEnumerable: IsEnumerable
};
function CheckSignature(a!, b!)
{
	Assert.IsFunction(a);
	Assert.IsFunction(b);
	if(a.Parameters.Length != b.Parameters.Length)
	{
		throw $"Parameters of {a} and {b} do not match";
	}
}


@|
	An Event class that allows other code to hook into this event with the +=/-= operators.
	Invocation can be done with the () operator.
|@
class Event
{
	const Array _CallList;
	const Function _CallPrototype;
	@|
		Event Constructor
		|PARAM callProto: The Function Signature of this event.
	|@
	function Event(Function callProto!)
	{
		Assert.IsFunction(callProto);
		_CallList = [];
		_CallPrototype = callProto;
	}

	@|
		Removes a subscribed listener from the event
		|PARAM func: The listener to unsubscribe.
		|RET: void
	|@
	function Remove(func!)
	{
		_CallList.Remove(func);
	}

	@|
		Adds a listener to event
		|PARAM func: The listener to subscribe.
		|RET: void
	|@
	function Add(func!)
	{
		CheckSignature(_CallPrototype, func);
		_CallList.Add(func);
	}

	@|
		Invokes the Event
		|PARAM args: the parameters for the event
		|RET: void
	|@
	function Invoke(args*)
	{
		foreach(func in _CallList)
		{
			func.Invoke(args);
		}
	}


	@|
		Operator Override for '+='
		|PARAM func: The listener to subscribe.
		|RET: void
	|@
	function any op_AddAssign(func!) => Add(func);

	@|
		Operator Override for '-='
		|PARAM func: The listener to unsubscribe.
		|RET: void
	|@
	function any op_SubtractAssign(func!) => Remove(func);

	@|
		Operator Override for '()'
		|PARAM args: the parameters for the event
		|RET: void
	|@

	function any op_Invoke(args*) => Invoke(args);

}


const Events = { Event: Event };

@|
	A simple Logger class with OnLog and OnWarn Events
|@
class Logger
{
	const Events.Event OnLog;
	const Events.Event OnWarn;

	@|
		Logger Constructor
	|@
	function Logger()
	{
		OnLog = new Events.Event(function(msg) {});
		OnWarn = new Events.Event(function(msg) {});
	}

	@|
		Logs a message
		|PARAM msg any: Object that will be logged.
		|RET void:
	|@
	function Log(msg)
	{
		OnLog.Invoke(msg);
	}

	@|
		Logs a warning
		|PARAM msg any: Object that will be logged.
		|RET void:
	|@
	function Warn(msg)
	{
		OnWarn.Invoke(msg);
	}
}

@|
	A simple Logger class that supports adding a tag to every log written.
|@
class TagLogger : Logger
{

	let string LogTag = "[LOG]";
	let string WarnTag = "[WARN]";

	@|
		Logger Constructor
	|@
	function TagLogger()
	{
		base.Logger();
	}

	@|
		Logs a message
		|PARAM msg any: Message to Log
		|RET void:
	|@
	function Log(msg)
	{
		base.Log($"{LogTag} {msg}");
	}

	@|
		Logs a warning
		|PARAM msg any: Warning to Log
		|RET void:
	|@
	function Warn(msg)
	{
		base.Warn($"{WarnTag} {msg}");
	}
}

@|
	Creates a Default Logger hooked up to the Console Output
	|RET System.Logging.Logger: Default Logger Instance
|@
function Logger CreateDefaultLogger()
{
	let l = new Logger();
	l.OnLog += Console.WriteLine;
	l.OnWarn += Console.WriteLine;
	return l;
}


const Logging = { 
	Logger: Logger,
	TagLogger: TagLogger,
	CreateDefault: CreateDefaultLogger
};

@|
	Sums numbers from 1 to N
	|PARAM n num: Positive Number
	|RET num: Sum from 1 to N
|@
const compiled fast function num Sum(num n)
{
	if(n < 0)
	{
		throw "Can only sum non negative numbers";
	}
	let r = 0;
	for(let i = 0; i < n; i++)
	{
		r += i;
	}
	return r;
}


@|
	Returns True is the specified number n is a Prime Number
	|PARAM n num: Positive Number
	|RET num: True if n is Prime
|@
const compiled fast function num IsPrime(num n)
{
	if(n <= 0)
	{
		throw $"Can not calculate prime for {n}";
	}
	if(n == 1)
	{
		return false;
	}
	if(n == 2)
	{
		return true;
	}
	if(n % 2 == 0)
	{
		return false;
	}
	const nSqrt = Math.Sqrt(n);
	for(let i = 3; i < nSqrt; i += 2)
	{
		if(n % i == 0)
		{
			return false;
		}
	}
	return true;
}

const SysMath = {
	IsPrime: IsPrime,
	Sum: Sum
};

@|
	Returns an Enumerable of prime numbers
	|RET Enumerable: Enumerable of Prime Numbers
|@
function Table Primes()
{
	function Table GetEnumerator()
	{
		let i = 1;
		function num GetCurrent() => i;
		compiled fast function bool MoveNext()
		{
			i += 2;
			while(!System.Math.IsPrime(i))
			{
				i += 2;
			}
			return true;
		}

		return {
			GetCurrent: GetCurrent,
			MoveNext: MoveNext
		};
	}
	return {
		GetEnumerator: GetEnumerator
	};
}

@|
	Returns an Infinite Enumerable
	|PARAM obj any: The object that will infinitely repeat in this enumerable
	|RET Enumerable: Infinite Enumerable
|@
function Table Infinite(any obj)
{
	function Table GetEnumerator()
	{
		function any GetCurrent() => obj;
		function bool MoveNext() => true;
		return {
			GetCurrent: GetCurrent,
			MoveNext: MoveNext
		};
	}
	return {
		GetEnumerator: GetEnumerator
	};
}

@|
	Returns an Enumerable that repeats the same object 'number' times.
	|PARAM obj any: The object that will repeat in this enumerable
	|PARAM number num: The amount of repetitions.
	|RET Enumerable: Enumerable
|@
function Table Repeat(any obj, num number)
{
	if(number < 0)
	{
		throw "Repeat amount can not be negative";
	}

	function Table GetEnumerator()
	{
		let i = 0;
		function any GetCurrent() => obj;
		function bool MoveNext()
		{
			i++;
			return i <= number;
		}
		return {
			GetCurrent: GetCurrent,
			MoveNext: MoveNext
		};
	}
	return {
		GetEnumerator: GetEnumerator
	};
}

@|
	Returns an Enumerable that counts from an arbitrary number to an arbitrary number
	|PARAM from num: Start Number
	|PARAM to num: End Number.
	|PARAM step num: Step Number
	|RET Enumerable: Enumerable
|@
function Table Range(num from, num to, num step?)
{
	step ??= 1;
	if(from > to && step >= 0)
	{
		throw "Range Step must be negative from " + from + " to " + to;
	}
	if(from < to && step <= 0)
	{
		throw "Range Step must be positive from " + from + " to  " + to;
	}

	function Table GetEnumerator()
	{
		let current = from - step;
		function num GetCurrent() => current;
		function bool MoveNext()
		{
			current += step;
			return  !(from < to && current >= to) &&
					!(from > to && current <= to);
		}
		return {
			GetCurrent: GetCurrent,
			MoveNext: MoveNext
		};
	}

	return {
		GetEnumerator: GetEnumerator
	};
}


const Enumerables = {
	Range: Range,
	Repeat: Repeat,
	Infinite: Infinite,
	Primes: Primes
};
@|
	Supports rudimentary source code parsing.
|@
class SourceReader
{
	const string _src;
	let num _current;
	@|
		Source Reader Constructor
		|PARAM src string: The Source code
	|@
	function SourceReader(src!)
	{
		Assert.IsString(src);
		_src = src;
		_current = 0;
	}

	@|
		Returns true if the next string sequence is equal to str
		|PARAM str string: The string sequence to test against
		|RET bool: True if the next string sequence is equal to str
	|@
	compiled fast function bool Is(string str!)
	{
		for(let i = 0; i < str.Length; i++)
		{
			if(GetCurrent(i) != str[i])
			{
				return false;
			}
		}
		return true;
	}

	@|
		Consumes the specified string from the source reader.
		If the specified string does not match the string sequence in the reader, an error is thrown
		|PARAM str string: The string sequence to test against
		|RET: void
	|@
	function string Eat(string str!)
	{
		if(!Is(str))
		{
			throw $"Expected {str}";
		}

		_current += str.Length;
		return str;
	}

	@|
		Returns true if the next character is a whitespace character
		|RET bool: True if the next character is a whitespace character
	|@
	function bool IsWhiteSpace()
	{
		return Is("\n") || Is("\r") || Is(" ") || Is("\t");
	}


	@|
		Skips all whitespace characters
		|RET: void
	|@
	compiled fast function SkipWhiteSpace()
	{
		while(!IsEOF() && IsWhiteSpace())
		{
			MoveNext();
		}
	}

	@|
		Parses a word
		|RET string: Parsed Word String
	|@
	compiled fast function string ParseWord()
	{
		let r = "";
		while(!IsWhiteSpace())
		{
			r += GetCurrent();
			MoveNext();
		}
		return r;
	}

	@|
		Returns True if the current reader position plus the offset is out of bounds
		|RET bool:
	|@
	function bool IsEOF(num offset?) => (_current + (offset ?? 0)) >= _src.Length || (_current + (offset ?? 0)) < 0;
	@|
		Returns a character at the specified offset(default=0) or '\0' if IsEOF(offset) is true.
		|RET string:
	|@
	function string GetCurrent(num offset?) => IsEOF(offset) ? "\0" : _src[_current + (offset ?? 0)];

	@|
		Moves the reader to the next position
		|RET void:
	|@
	function MoveNext()
	{
		_current++;
	}

	@|
		Parses a single line comment
		|RET string: Parsed Comment String
	|@
	compiled fast function string ReadComment()
	{
		let r = "";
		while(!IsEOF() && GetCurrent() != "\n")
		{

			r += GetCurrent();
			MoveNext();
		}

		return r;
	}

	@|
		Parses a multi line comment
		|RET string: Parsed Comment String
	|@
	compiled fast function string ReadMultilineComment()
	{
		let r = GetCurrent();
		MoveNext();
		r += GetCurrent();
		MoveNext();
		while(!IsEOF(1) && !Is("*/"))
		{
			r += GetCurrent();
			MoveNext();
		}
		r += GetCurrent();
		MoveNext();
		r += GetCurrent();
		MoveNext();

		return r;
	}


	@|
		Parses a meta comment
		|RET string: Parsed Comment String
	|@
	compiled fast function string ReadMetaComment()
	{
		let r = GetCurrent();
		MoveNext();
		r += GetCurrent();
		MoveNext();
		while(!IsEOF(1) && !Is("|@"))
		{
			r += GetCurrent();
			MoveNext();
		}
		r += GetCurrent();
		MoveNext();
		r += GetCurrent();
		MoveNext();

		return r;
	}


	@|
		Parses a string expression
		|RET string: Parsed String
	|@
	compiled fast function string ReadString()
	{
		const terminator = GetCurrent();
		let r = terminator;
		MoveNext();
		
		while(!IsEOF())
		{
			let current = GetCurrent();
			if(current == terminator)
			{
				break;
			}
			if(current == "\\")
			{
				const escaped = GetCurrent(1);
				r += "\\" + escaped;
				MoveNext();
				MoveNext();
				continue;
			}

			r += current;
			MoveNext();
		}

		r += Eat(terminator);

		return r;
	}

	@|
		Removes all comments from the source code and returns it.
		|RET string: Stripped Source
	|@
	compiled fast function string StripComments()
	{
		let r = "";
		while(!IsEOF())
		{
			let c = GetCurrent();
			if(c == "/" && GetCurrent(1) == "/")
			{
				ReadComment();
			}
			else if(c == "/" && GetCurrent(1) == "*")
			{
				ReadMultilineComment();
			}
			else if(c == "@" && GetCurrent(1) == "|")
			{
				ReadMetaComment();
			}
			else if(c == "\"")
			{
				r += ReadString();
			}
			else
			{
				r += c;
				MoveNext();
			}
		}

		return r;
	}
}
const System = {
	Assert: Assert,
	Enumerables: Enumerables,
	Events: Events,
	Logging: Logging,
	SourceReader: SourceReader,
	Math: SysMath
};
export default System;
