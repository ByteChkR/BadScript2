let Native = Runtime.Native; @| Asserts that the specified object is a String |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsString(obj) { if(obj == null || !Native.IsString(obj)) => throw "Expected String"; } @| Asserts that the specified object is a Boolean |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsBoolean(obj) { if(obj == null || !Native.IsBoolean(obj)) => throw "Expected Boolean"; } @| Asserts that the specified object is a Number |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsNumber(obj) { if(obj == null || !Native.IsNumber(obj)) => throw "Expected Number"; } @| Asserts that the specified object is an Array |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsArray(obj) { if(obj == null || !Native.IsArray(obj)) => throw "Expected Array"; } @| Asserts that the specified object is a Table |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsTable(obj) { if(obj == null || !Native.IsTable(obj)) => throw "Expected Table"; } @| Asserts that the specified object is a Function |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsFunction(obj) { if(obj == null || !Native.IsFunction(obj)) => throw "Expected Function"; } @| Asserts that the specified object is an Enumerable |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsEnumerable(obj) { if(obj == null || !Native.IsEnumerable(obj)) => throw "Expected Enumerable"; } @| Asserts that the specified object is an Enumerator |PARAM obj: object that will be tested |RET: void(throws if assertion fails) |@ function IsEnumerator(obj) { if(obj == null || !Native.IsEnumerator(obj)) => throw "Expected Enumerator"; } const Assert = { IsString: IsString, IsBoolean: IsBoolean, IsNumber: IsNumber, IsArray: IsArray, IsTable: IsTable, IsFunction: IsFunction, IsEnumerator: IsEnumerator, IsEnumerable: IsEnumerable } function CheckSignature(a!, b!) { Assert.IsFunction(a); Assert.IsFunction(b); if(a.Parameters.Length != b.Parameters.Length) { throw $"Parameters of {a} and {b} do not match"; } } @| An Event class that allows other code to hook into this event with the +=/-= operators. Invocation can be done with the () operator. |@ class Event { let _CallList; let _CallPrototype; @| Event Constructor |PARAM callProto: The Function Signature of this event. |@ function Event(callProto!) { Assert.IsFunction(callProto); _CallList = []; _CallPrototype = callProto; } @| Removes a subscribed listener from the event |PARAM func: The listener to unsubscribe. |RET: void |@ function Remove(func!) { _CallList.Remove(func); } @| Adds a listener to event |PARAM func: The listener to subscribe. |RET: void |@ function Add(func!) { CheckSignature(_CallPrototype, func); _CallList.Add(func); } @| Invokes the Event |PARAM args: the parameters for the event |RET: void |@ function Invoke(args*) { foreach(func in _CallList) { func.Invoke(args); } } @| Operator Override for '+=' |PARAM func: The listener to subscribe. |RET: void |@ function op_AddAssign(func!) => Add(func); @| Operator Override for '-=' |PARAM func: The listener to unsubscribe. |RET: void |@ function op_SubtractAssign(func!) => Remove(func); @| Operator Override for '()' |PARAM args: the parameters for the event |RET: void |@ function op_Invoke(args*) => Invoke(args); } const Events = { Event: Event } @| A simple Logger class with OnLog and OnWarn Events |@ class Logger { let OnLog; let OnWarn; @| Logger Constructor |@ function Logger() { OnLog = new Events.Event(function(msg) => {}); OnWarn = new Events.Event(function(msg) => {}); } @| Logs a message |RET: void |@ function Log(msg) { OnLog.Invoke(msg); } @| Logs a warning |RET: void |@ function Warn(msg) { OnWarn.Invoke(msg); } } @| A simple Logger class that supports adding a tag to every log written. |@ class TagLogger : Logger { let LogTag = "[LOG]"; let WarnTag = "[WARN]"; @| Logger Constructor |@ function TagLogger() { base.Logger(); } @| Logs a message |PARAM msg: Message to Log |RET: void |@ function Log(msg) { base.Log($"{LogTag} {msg}"); } @| Logs a warning |PARAM msg: Warning to Log |RET: void |@ function Warn(msg) { base.Warn($"{WarnTag} {msg}"); } } @| Creates a Default Logger hooked up to the Console Output |RET: Default Logger Instance |@ function CreateDefaultLogger() { let l = new Logger(); l.OnLog += Console.WriteLine; l.OnWarn += Console.WriteLine; return l; } const Logging = { Logger: Logger, TagLogger: TagLogger, CreateDefault: CreateDefaultLogger } @| Sums numbers from 1 to N |PARAM n: Positive Number |RET: Sum from 1 to N |@ const compiled fast function Sum(num n) { if(n < 0) { throw "Can only sum non negative numbers"; } let r = 0; for(let i = 0; i < n; i++) { r += i; } return r; } @| Returns True is the specified number n is a Prime Number |PARAM n: Positive Number |RET: True if n is Prime |@ const compiled fast function IsPrime(num n) { if(n <= 0) { throw $"Can not calculate prime for {n}"; } if(n == 1) { return false; } if(n == 2) { return true; } if(n % 2 == 0) { return false; } const nSqrt = Math.Sqrt(n); for(let i = 3; i < nSqrt; i += 2) { if(n % i == 0) { return false; } } return true; } const SysMath = { IsPrime: IsPrime, Sum: Sum } @| Returns an Enumerable of prime numbers |RET: Enumerable of Prime Numbers |@ function Primes() { function GetEnumerator() { let i = 1; function GetCurrent() => i; compiled fast function MoveNext() { i += 2; while(!System.Math.IsPrime(i)) { i += 2; } return true; } return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } @| Returns an Infinite Enumerable |PARAM obj: The object that will infinitely repeat in this enumerable |RET: Infinite Enumerable |@ function Infinite(obj) { function GetEnumerator() { function GetCurrent() => obj; function MoveNext() => true; return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } @| Returns an Enumerable that repeats the same object 'num' times. |PARAM obj: The object that will repeat in this enumerable |PARAM num: The amount of repetitions. |RET: Enumerable |@ function Repeat(obj, num) { Assert.IsNumber(num); if(num < 0) { throw "Repeat amount can not be negative"; } function GetEnumerator() { let i = 0; function GetCurrent() => obj; function MoveNext() { i++; return i <= num; } return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } @| Returns an Enumerable that counts from an arbitrary number to an arbitrary number |PARAM from: Start Number |PARAM to: End Number. |PARAM step: Step Number |RET: Enumerable |@ function Range(from, to, step?) { step ??= 1; Assert.IsNumber(from); Assert.IsNumber(to); Assert.IsNumber(step); if(from > to && step >= 0) { throw "Range Step must be negative from " + from + " to " + to; } if(from < to && step <= 0) { throw "Range Step must be positive from " + from + " to " + to; } function GetEnumerator() { let current = from - step; function GetCurrent() => current; function MoveNext() { current += step; return !(from < to && current >= to) && !(from > to && current <= to); } return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } const Enumerables = { Range: Range, Repeat: Repeat, Infinite: Infinite, Primes: Primes } @| Supports rudimentary source code parsing. |@ class SourceReader { let _src; let _current; @| Source Reader Constructor |PARAM src: The Source code |@ function SourceReader(src!) { Assert.IsString(src); _src = src; _current = 0; } @| Returns true if the next string sequence is equal to str |PARAM str: The string sequence to test against |RET: True if the next string sequence is equal to str |@ compiled fast function Is(str!) { Assert.IsString(str); for(let i = 0; i < str.Length; i++) { if(GetCurrent(i) != str[i]) { return false; } } return true; } @| Consumes the specified string from the source reader. If the specified string does not match the string sequence in the reader, an error is thrown |PARAM str: The string sequence to test against |RET: void |@ function Eat(str!) { Assert.IsString(str); if(!Is(str)) { throw $"Expected {str}"; } _current += str.Length; } @| Returns true if the next character is a whitespace character |RET: True if the next character is a whitespace character |@ function IsWhiteSpace() { return Is("\n") || Is("\r") || Is(" ") || Is("\t"); } @| Skips all whitespace characters |RET: void |@ compiled fast function SkipWhiteSpace() { while(!IsEOF() && IsWhiteSpace()) { MoveNext(); } } @| Parses a word |RET: Parsed Word String |@ compiled fast function ParseWord() { let r = ""; while(!IsWhiteSpace()) { r += GetCurrent(); MoveNext(); } return r; } @| Returns True if the current reader position plus the offset is out of bounds |RET: bool |@ function IsEOF(offset?) => (_current + (offset ?? 0)) >= _src.Length || (_current + (offset ?? 0)) < 0; @| Returns a character at the specified offset(default=0) or '\0' if IsEOF(offset) is true. |RET: string |@ function GetCurrent(offset?) => IsEOF(offset) ? "\0" : _src[_current + (offset ?? 0)]; @| Moves the reader to the next position |RET: void |@ function MoveNext() { _current++; } @| Parses a single line comment |RET: Parsed Comment String |@ compiled fast function ReadComment() { let r = ""; while(!IsEOF() && GetCurrent() != "\n") { r += GetCurrent(); MoveNext(); } return r; } @| Parses a multi line comment |RET: Parsed Comment String |@ compiled fast function ReadMultilineComment() { let r = GetCurrent(); MoveNext(); r += GetCurrent(); MoveNext(); while(!IsEOF(1) && !Is("*/")) { r += GetCurrent(); MoveNext(); } r += GetCurrent(); MoveNext(); r += GetCurrent(); MoveNext(); return r; } @| Parses a meta comment |RET: Parsed Comment String |@ compiled fast function ReadMetaComment() { let r = GetCurrent(); MoveNext(); r += GetCurrent(); MoveNext(); while(!IsEOF(1) && !Is("|@")) { r += GetCurrent(); MoveNext(); } r += GetCurrent(); MoveNext(); r += GetCurrent(); MoveNext(); return r; } @| Parses a string expression |RET: Parsed String |@ compiled fast function ReadString() { let r = GetCurrent(); MoveNext(); while(!IsEOF() && GetCurrent() != "\"") { r += GetCurrent(); if(GetCurrent() == "\\") { MoveNext(); r += GetCurrent(); } MoveNext(); } r += GetCurrent(); MoveNext(); return r; } @| Removes all comments from the source code and returns it. |RET: Stripped Source |@ compiled fast function StripComments() { let r = ""; while(!IsEOF()) { let c = GetCurrent(); if(c == "/" && GetCurrent(1) == "/") { ReadComment(); } else if(c == "/" && GetCurrent(1) == "*") { ReadMultilineComment(); } else if(c == "@" && GetCurrent(1) == "|") { ReadMetaComment(); } else if(c == "\"") { r += ReadString(); } else { r += c; MoveNext(); } } return r; } } const System = { Assert: Assert, Enumerables: Enumerables, Events: Events, Logging: Logging, SourceReader: SourceReader, Math: SysMath } Runtime.Export("System", System);