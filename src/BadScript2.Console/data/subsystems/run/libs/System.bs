let Native = Runtime.Native; function IsString(obj) { if(obj == null || !Native.IsString(obj)) => throw "Expected String"; } function IsBoolean(obj) { if(obj == null || !Native.IsBoolean(obj)) => throw "Expected Boolean"; } function IsNumber(obj) { if(obj == null || !Native.IsNumber(obj)) => throw "Expected Number"; } function IsArray(obj) { if(obj == null || !Native.IsArray(obj)) => throw "Expected Array"; } function IsTable(obj) { if(obj == null || !Native.IsTable(obj)) => throw "Expected Table"; } function IsFunction(obj) { if(obj == null || !Native.IsFunction(obj)) => throw "Expected Function"; } function IsEnumerable(obj) { if(obj == null || !Native.IsEnumerable(obj)) => throw "Expected Enumerable"; } function IsEnumerator(obj) { if(obj == null || !Native.IsEnumerator(obj)) => throw "Expected Enumerator"; } const Assert = { IsString: IsString, IsBoolean: IsBoolean, IsNumber: IsNumber, IsArray: IsArray, IsTable: IsTable, IsFunction: IsFunction, IsEnumerator: IsEnumerator, IsEnumerable: IsEnumerable } function CheckSignature(a!, b!) { Assert.IsFunction(a); Assert.IsFunction(b); if(a.Parameters.Length != b.Parameters.Length) { throw $"Parameters of {a} and {b} do not match"; } } class Event { let _CallList; let _CallPrototype; function Event(callProto!) { Assert.IsFunction(callProto); _CallList = []; _CallPrototype = callProto; } function Remove(func!) { _CallList.Remove(func); } function Add(func!) { CheckSignature(_CallPrototype, func); _CallList.Add(func); } function Invoke(args*) { foreach(func in _CallList) { func.Invoke(args); } } function op_AddAssign(func!) => Add(func); function op_SubtractAssign(func!) => Remove(func); function op_Invoke(args*) => Invoke(args); } const Events = { Event: Event } class Logger { let OnLog; let OnWarn; function Logger() { OnLog = new Events.Event(function(msg) => {}); OnWarn = new Events.Event(function(msg) => {}); } function Log(msg) { OnLog.Invoke(msg); } function Warn(msg) { OnWarn.Invoke(msg); } } class TagLogger : Logger { let LogTag = "[LOG]"; let WarnTag = "[WARN]"; function TagLogger() { base.Logger(); } function Log(msg) { base.Log($"{LogTag} {msg}"); } function Warn(msg) { base.Warn($"{WarnTag} {msg}"); } } function CreateDefaultLogger() { let l = new Logger(); l.OnLog += Console.WriteLine; l.OnWarn += Console.WriteLine; return l; } const Logging = { Logger: Logger, TagLogger: TagLogger, CreateDefault: CreateDefaultLogger } function Infinite(obj) { function GetEnumerator() { function GetCurrent() => obj; function MoveNext() => true; return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } function Repeat(obj, num) { Assert.IsNumber(num); if(num < 0) { throw "Repeat amount can not be negative"; } function GetEnumerator() { let i = 0; function GetCurrent() => obj; function MoveNext() { i++; return i <= num; } return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } function Range(from, to, step?) { step ??= 1; Assert.IsNumber(from); Assert.IsNumber(to); Assert.IsNumber(step); if(from > to && step >= 0) { throw "Range Step must be negative from " + from + " to " + to; } if(from < to && step <= 0) { throw "Range Step must be positive from " + from + " to " + to; } function GetEnumerator() { let current = from - step; function GetCurrent() => current; function MoveNext() { current += step; return !(from < to && current >= to) && !(from > to && current <= to); } return { GetCurrent: GetCurrent, MoveNext: MoveNext } } return { GetEnumerator: GetEnumerator } } const Enumerables = { Range: Range, Repeat: Repeat, Infinite: Infinite } class LinqHelper { function Any(e!, func!) { foreach(v in e) { if(func(v)) { return true; } } return false; } function All(e!, func!) { foreach(v in e) { if(!func(v)) { return false; } } return true; } function FirstOrDefault(e!, func!) { foreach(v in e) { if(func(v)) { return v; } } return null; } function First(e!, func!) { let v = FirstOrDefault(e, func); if(v == null) { throw "Sequence contains no matching element"; } return v; } function LastOrDefault(e!, func!) { let r = null; foreach(v in e) { if(func(v)) { r = v; } } return r; } function Last(e!, func!) { let v = LastOrDefault(e, func); if(v == null) { throw "Sequence contains no matching element"; } return v; } function ToArray(e!) { let r = []; foreach(v in e) { r.Add(v); } return r; } } let helper = new LinqHelper(); class LinqEnumerable { function GetEnumerator() => throw "GetEnumerator is not implemented"; function Select(func!) => new SelectEnumerable(this, func); function Where(func!) => new WhereEnumerable(this, func); function Take(count!) => new TakeEnumerable(this, count); function Skip(count!) => new SkipEnumerable(this, count); function Any(func!) => helper.Any(this, func); function All(func!) => helper.All(this, func); function FirstOrDefault(func!) => helper.FirstOrDefault(this, func); function First(func!) => helper.First(this, func); function LastOrDefault(func!) => helper.LastOrDefault(this, func); function Last(func!) => helper.Last(this, func); function ToArray() => helper.ToArray(this); } class ArrayEnumerable : LinqEnumerable { let _inner; function ArrayEnumerable(inner!) { Assert.IsArray(inner); _inner = inner; } function GetEnumerator() => _inner.GetEnumerator(); } class LinqEnumerator { function GetCurrent() => throw "GetCurrent is not implemented"; function MoveNext() => throw "MoveNext is not implemented"; } class TableEnumerator : LinqEnumerator { let _inner; let _keys; function TableEnumerator(inner!) { Assert.IsTable(inner); _inner = inner; _keys = inner.Keys.GetEnumerator(); } function GetCurrent() { let key = _keys.GetCurrent(); return {key: key, value: _inner[key]} } function MoveNext() => _keys.MoveNext(); } class TableEnumerable : LinqEnumerable { let _inner; function TableEnumerable(inner!) { Assert.IsTable(inner); _inner = inner; } function GetEnumerator() => new TableEnumerator(_inner); } class SelectEnumerator : LinqEnumerator { let _selector; let _inner; function SelectEnumerator(inner!, selector!) { Assert.IsEnumerator(inner); Assert.IsFunction(selector); _inner = inner; _selector = selector; } function GetCurrent() => _selector(_inner.GetCurrent()); function MoveNext() => _inner.MoveNext(); } class SelectEnumerable : LinqEnumerable { let _selector; let _inner; function SelectEnumerable(inner!, selector!) { Assert.IsFunction(selector); Assert.IsEnumerable(inner); _selector = selector; _inner = inner; } function GetEnumerator() => new SelectEnumerator(_inner.GetEnumerator(), _selector); } class WhereEnumerator : LinqEnumerator { let _inner; let _filter; function WhereEnumerator(inner!, filter!) { Assert.IsEnumerator(inner); Assert.IsFunction(filter); _inner = inner; _filter = filter; } function GetCurrent() => _inner.GetCurrent(); function MoveNext() { let r = _inner.MoveNext(); if(!r) { return false; } while(!_filter(GetCurrent())) { r = _inner.MoveNext(); if(!r) { return false; } } return true; } } class WhereEnumerable : LinqEnumerable { let _inner; let _filter; function WhereEnumerable(inner!, filter!) { Assert.IsEnumerable(inner); Assert.IsFunction(filter); _inner = inner; _filter = filter; } function GetEnumerator() => new WhereEnumerator(_inner.GetEnumerator(), _filter); } class TakeEnumerator : LinqEnumerator { let _inner; let _current; let _count; function TakeEnumerator(inner!, count!) { Assert.IsEnumerator(inner); Assert.IsNumber(count); _inner = inner; _count = count; _current = 0; } function GetCurrent() => _inner.GetCurrent(); function MoveNext() { if(_count <= _current) { return false; } _current++; return _inner.MoveNext(); } } class TakeEnumerable : LinqEnumerable { let _inner; let _count; function TakeEnumerable(inner!, count!) { Assert.IsEnumerable(inner); Assert.IsNumber(count); _inner = inner; _count = count; } function GetEnumerator() => new TakeEnumerator(_inner.GetEnumerator(), _count); } class SkipEnumerator : LinqEnumerator { let _inner; let _count; let _firstStart; function SkipEnumerator(inner!, count!) { Assert.IsEnumerator(inner); Assert.IsNumber(count); _inner = inner; _count = count; _firstStart = true; } function GetCurrent() => _inner.GetCurrent(); function MoveNext() { if(_firstStart) { _firstStart = false; for(let i = 0; i < _count; i++) { _inner.MoveNext(); } } return _inner.MoveNext(); } } class SkipEnumerable : LinqEnumerable { let _inner; let _count; function SkipEnumerable(inner!, count!) { Assert.IsEnumerable(inner); Assert.IsNumber(count); _inner = inner; _count = count; } function GetEnumerator() => new SkipEnumerator(_inner.GetEnumerator(), _count); } function FromArray(array!) => new ArrayEnumerable(array); function FromTable(table!) => new TableEnumerable(table); const Linq = { FromArray: FromArray, FromTable: FromTable } class SourceReader { let _src; let _current; function SourceReader(src!) { Assert.IsString(src); _src = src; _current = 0; } function Is(str!) { Assert.IsString(str); for(let i = 0; i < str.Length; i++) { if(GetCurrent(i) != str[i]) { return false; } } return true; } function Eat(str!) { Assert.IsString(str); if(!Is(str)) { throw $"Expected {str}"; } _current += str.Length; } function IsWhiteSpace() { return Is("\n") || Is("\r") || Is(" ") || Is("\t"); } function SkipWhiteSpace() { while(!IsEOF() && IsWhiteSpace()) { MoveNext(); } } function ParseWord() { let r = ""; while(!IsWhiteSpace()) { r += GetCurrent(); MoveNext(); } return r; } function IsEOF() => _current >= _src.Length || _current < 0; function GetCurrent(offset?) => IsEOF() ? "\0" : _src[_current + (offset ?? 0)]; function MoveNext() { _current++; } function ReadComment() { let r = ""; while(!IsEOF() && GetCurrent() != "\n") { r += GetCurrent(); MoveNext(); } return r; } function ReadMultilineComment() { let r = GetCurrent(); MoveNext(); r += GetCurrent(); MoveNext(); while(!IsEOF() && GetCurrent() != "*" && GetCurrent(1) != "/") { r += GetCurrent(); MoveNext(); } r += GetCurrent(); MoveNext(); r += GetCurrent(); MoveNext(); return r; } function ReadString() { let r = GetCurrent(); MoveNext(); while(!IsEOF() && GetCurrent() != "\"") { r += GetCurrent(); if(GetCurrent() == "\\") { MoveNext(); r += GetCurrent(); } MoveNext(); } r += GetCurrent(); MoveNext(); return r; } function StripComments() { let r = ""; while(!IsEOF()) { let c = GetCurrent(); if(c == "/" && GetCurrent(1) == "/") { ReadComment(); } else if(c == "/" && GetCurrent(1) == "*") { ReadMultilineComment(); } else if(c == "\"") { r += ReadString(); } else { r += c; MoveNext(); } } return r; } } const System = { Assert: Assert, Enumerables: Enumerables, Events: Events, Linq: Linq, Logging: Logging, SourceReader: SourceReader } Runtime.Export("System", System);