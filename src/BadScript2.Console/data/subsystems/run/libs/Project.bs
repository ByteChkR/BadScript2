let Package;function(){Package = Runtime.Import("Package");}(); let System;function(){System = Package.Import("System");}(); const Assert = System.Assert; const Logging = System.Logging; const SourceReader = System.SourceReader; class ProjectLogger : Logging.TagLogger { function ProjectLogger() { base.TagLogger(); } function Log(msg) { base.Log($"[PROJ] {msg}"); } function Warn(msg) { base.Warn($"[PROJ] {msg}"); } } let Logger = new ProjectLogger(); Logger.OnLog += Console.WriteLine; Logger.OnWarn += Console.WriteLine; class Project { let settings; let preprocessTasks; let postprocessTasks; let globalTasks; function Project() { settings = {} preprocessTasks = []; postprocessTasks = []; globalTasks = []; } function AddSetting(name!, setting!) { Assert.IsString(name); Logger.Log($"Add Setting '{name}'"); settings[name] = setting; return this; } function AddSource(file!) { if(!settings.Keys.Contains("Sources")) { settings.Sources = []; } Logger.Log($"Add Source '{file}'"); settings.Sources.Add(file); return this; } function GetSettings() => settings; function GetSetting(name!) { Assert.IsString(name); if(!settings.Keys.Contains(name)) { throw $"Setting '{name}' does not exist"; } return settings[name]; } function LoadSetting(name!, file!) { Assert.IsString(name); Assert.IsString(file); AddSetting(name, Json.FromJson(IO.File.ReadAllText(file))); return this; } function AddGlobalTask(name!, func!) { Assert.IsString(name); Assert.IsFunction(func); Logger.Log($"Add Global Task '{name}'"); globalTasks.Add({name: name, func: func}); return this; } function AddPreprocessTask(name!, func!) { Assert.IsString(name); Assert.IsFunction(func); preprocessTasks.Add({name: name, func: func}); return this; } function AddPostprocessTask(name!, func!) { Assert.IsString(name); Assert.IsFunction(func); postprocessTasks.Add({name: name, func: func}); return this; } function ExpandSourceFiles() { let sourceFiles = GetSetting("Sources"); Console.WriteLine($"Expanding Source Files: {sourceFiles}"); for(let i = sourceFiles.Length - 1; i >= 0; i--) { const file = sourceFiles[i]; if(file.Contains("*")) { sourceFiles.RemoveAt(i); const parts = file.Split("*"); const dir = parts[0]; const ext = parts[1]; sourceFiles.InsertRange(i, IO.Directory.GetFiles(dir, $"*{ext}", false)); } } Console.WriteLine($"Expanded Source Files: {sourceFiles}"); } function Run() { ExpandSourceFiles(); foreach(globalTask in globalTasks) { Logger.Log($"Running Task: {globalTask.name}"); globalTask.func(); } let sourceFiles = GetSetting("Sources"); for(let i = 0; i < sourceFiles.Length; i++) { foreach(preTask in preprocessTasks) { Logger.Log($"Running Preprocess Task '{preTask.name}' on '{sourceFiles[i]}'"); sourceFiles[i] = preTask.func(sourceFiles[i]); } } Logger.Log("Combining Source Files..."); let src = ""; foreach(sourceFile in sourceFiles) { src += $"{IO.File.ReadAllText(sourceFile)}\n"; } foreach(postTask in postprocessTasks) { Logger.Log($"Running Postprocess Task '{postTask.name}'"); src = postTask.func(src); } } } Runtime.Export("Project", Project); function SaveToFile(output) { function SaveToFile(src) { Console.WriteLine($"Output: {output}") IO.Directory.CreateDirectory(IO.Path.GetDirectoryName(IO.Path.GetFullPath(output))); IO.File.WriteAllText(output, src); return src; } return SaveToFile; } function InstallToLib(project) { let appName = project.GetSetting("AppInfo").Name; return SaveToFile(IO.Path.Combine(IO.Directory.GetStartupDirectory(), "data", "subsystems", "run", "libs", appName + ".bs")); } function InstallToRun(project) { let appName = project.GetSetting("AppInfo").Name; return SaveToFile(IO.Path.Combine(IO.Directory.GetStartupDirectory(), "data", "subsystems", "run", appName + ".bs")); } function InstallToStartup(project) { let appName = project.GetSetting("AppInfo").Name; return SaveToFile(IO.Path.Combine(IO.Directory.GetStartupDirectory(), "data", "subsystems", "run", "startup", appName + ".bs")); } function SaveToOutput(project) { function SaveToOutput(src) { let buildInfo = project.GetSetting("BuildInfo"); Console.WriteLine($"Output: {buildInfo.OutputFile}"); IO.Directory.CreateDirectory(IO.Path.GetDirectoryName(IO.Path.GetFullPath(buildInfo.OutputFile))); IO.File.WriteAllText(buildInfo.OutputFile, src); return src; } return SaveToOutput; } function Minify(src) { let reader = new SourceReader(src); let newSrc = reader.StripComments(); newSrc = newSrc.Replace("\n", " ") .Replace("\r", " ") .Replace("\t", " "); let parts = newSrc.Split(" ", true); newSrc = ""; foreach(part in parts) { newSrc += part + " "; } return newSrc.Trim(); } function GetElement(obj!, parts!, index?) { index ??= 0; Assert.IsArray(parts); Assert.IsNumber(index); if(index < parts.Length - 1) { return GetElement(obj[parts[index]], parts, index + 1); } return obj[parts[index]]; } function ProcessEvals(builder) { function ProcessEvals(src) { let reader = new SourceReader(src); let newSrc = ""; let startKey = "$" + "("; while(!reader.IsEOF()) { if(reader.Is(startKey)) { reader.Eat(startKey); reader.SkipWhiteSpace(); let parts = []; let current = ""; while(!reader.IsEOF() && !reader.Is(")")) { if(reader.Is(".")) { parts.Add(current); current = ""; } else { current += reader.GetCurrent(); } reader.MoveNext(); } parts.Add(current); reader.Eat(")"); let elem = GetElement(builder.GetSettings(), parts); Console.WriteLine($"Evaluated to: {elem}"); newSrc += elem; } else { newSrc += reader.GetCurrent(); reader.MoveNext(); } } return newSrc; } return ProcessEvals; } function RunFrom(file) { function RunFrom() { let dir = IO.Path.GetDirectoryName(file); let original = IO.Directory.GetCurrentDirectory(); IO.Directory.SetCurrentDirectory(dir); let name = IO.Path.GetFileName(file); Console.WriteLine("Running File: " + file); Runtime.Evaluate(IO.File.ReadAllText(name), file); IO.Directory.SetCurrentDirectory(original); } return RunFrom; } function ProcessImports(src) { let reader = new SourceReader(src); let newSrc = ""; let imports = []; while(!reader.IsEOF()) { if(reader.Is("\"")) { newSrc += reader.ReadString(); } else if(reader.Is("/") && reader.GetCurrent(1) == "/") { newSrc += reader.ReadComment(); } else if(reader.Is("/") && reader.GetCurrent(1) == "*") { newSrc += reader.ReadMultilineComment(); } else if(reader.Is("#import")) { reader.Eat("#import"); reader.SkipWhiteSpace(); let importName = reader.ParseWord(); let defineVar = !imports.Contains(importName); reader.SkipWhiteSpace(); reader.Eat("from"); reader.SkipWhiteSpace(); let importer = reader.ParseWord(); let insert = $"function(){{{importName} = {importer}.Import(\"{importName}\");}}();"; if(defineVar) { imports.Add(importName); insert = $"let {importName};" + insert; } Console.WriteLine($"Processing import '{importName}' from '{importer}'"); newSrc += insert; } else { newSrc += reader.GetCurrent(); reader.MoveNext(); } } return newSrc; } Runtime.Export("ProjectUtils", { SaveToFile: SaveToFile, SaveToOutput: SaveToOutput, Minify: Minify, InstallToLib: InstallToLib, InstallToStartup: InstallToStartup, InstallToRun: InstallToRun, ProcessImports: ProcessImports, ProcessEvals: ProcessEvals, RunFrom: RunFrom });