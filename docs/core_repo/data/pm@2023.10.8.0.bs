const Config = {}; const PackageApi = {}; function() { const appDataDirectory = IO.Path.Combine(Json.Settings.Subsystems.Run.AppDataDirectory, "PackageManager"); const originListDirectory = IO.Path.Combine(appDataDirectory, "origins"); const originFile = IO.Path.Combine(appDataDirectory, "origins.json"); const packageFile = IO.Path.Combine(appDataDirectory, "package.json"); IO.Directory.CreateDirectory(appDataDirectory); IO.Directory.CreateDirectory(originListDirectory); function SavePackageFile(packages) { IO.File.WriteAllText(packageFile, Json.ToJson(packages)); } function LoadPackageFile() { let package = {}; if(IO.File.Exists(packageFile)) { package = Json.FromJson(IO.File.ReadAllText(packageFile)); } else { IO.File.WriteAllText(packageFile, Json.ToJson(package)); } return package; } function SaveOriginsFile(origins) { IO.File.WriteAllText(originFile, Json.ToJson(origins)); } function LoadOriginsFile() { let origins = {}; if(IO.File.Exists(originFile)) { origins = Json.FromJson(IO.File.ReadAllText(originFile)); } else { IO.File.WriteAllText(originFile, Json.ToJson(origins)); } return origins; } class OriginList { let _origins; function OriginList(origins) { _origins = origins; } function Save() => SaveOriginsFile(_origins); function Reload() { _origins = LoadOriginsFile(); } function GetOrigins() => _origins; function Has(name) => Get(name) != null; function Get(name) { if(name in _origins) { return _origins[name]; } return null; } function Add(name, url, type) { if(Has(name)) { Console.WriteLine($"Origin with name {name} already exists. Aborting..."); } _origins[name] = {Url: url, Type: type}; SaveOriginsFile(_origins); } function Remove(name) { const origin = Get(name); const packageList = GetPackageListPath(name); if(IO.File.Exists(packageList)) { IO.File.Delete(packageList); } _origins.RemoveKey(name); SaveOriginsFile(_origins); } function GetPackageListPath(name) => IO.Path.Combine(originListDirectory, name) + ".json"; function CreateSearchContext(packageName) { foreach(originName in _origins.Keys) { const origin = _origins[originName]; if(origin.Type == "local") { const packageListPath = GetPackageListPath(originName); if(IO.File.Exists(packageListPath)) { const searchContext = new PackageSearchContext(Json.FromJson(IO.File.ReadAllText(packageListPath)), originName); if(searchContext.Has(packageName)) { return searchContext; } } } } foreach(originName in _origins.Keys) { const origin = _origins[originName]; if(origin.Type == "local") { continue; } const packageListPath = GetPackageListPath(originName); if(IO.File.Exists(packageListPath)) { const searchContext = new PackageSearchContext(Json.FromJson(IO.File.ReadAllText(packageListPath)), originName); if(searchContext.Has(packageName)) { return searchContext; } } } return null; } } class PackageSearchContext { const _packages; const _originName; function PackageSearchContext(packages, originName) { _originName = originName; _packages = packages; } function GetOrigin() => _originName; function Has(name) => Get(name) != null; function Get(name) { if(name in _packages) { return _packages[name]; } return null; } function IsTagAlias(package, tag) { if(!(tag in package.Tags)) { throw $"Tag {tag} does not exist!"; } return Runtime.Native.IsString(package.Tags[tag]); } function ResolveTag(package, tag) { let result = tag; while(IsTagAlias(package, result)) { result = package.Tags[result]; } return result; } function BuildInstallList(name, tag?, deps?, parent?) { const package = Get(name); if(package == null) { throw $"Package with the name {name} does not exist"; } const isLatest = tag == "latest"; tag = ResolveTag(package, tag ?? "latest"); deps ??= []; const existing = deps.FirstOrDefault(x => x.Name == name && x.Tag == tag); if(existing != null) { if(parent != null) { existing.DependentOf.Add({Name: parent.Name, Tag: parent.Tag}); } return deps; } const installEntry = {Name: name, Tag: tag, Type: package.Type, DependentOf: [], Dependencies: [], IsLatest: isLatest}; deps.Add(installEntry); if(parent != null) { installEntry.DependentOf.Add({Name: parent.Name, Tag: parent.Tag}); } const tagData = package.Tags[tag]; if("Dependencies" in tagData) { foreach(dep in tagData.Dependencies) { installEntry.Dependencies.Add({Name: dep.Name, Tag: ResolveTag(Get(dep.Name), dep.Tag)}); BuildInstallList(dep.Name, dep.Tag, deps, installEntry); } } return deps; } } class PackageList { let _packages; function PackageList(packages) { _packages = packages; } function Reload() { _packages = LoadPackageFile(); } function Save() => SavePackageFile(_packages); function GetPackages() => _packages; function GetAll(name) { if(name in _packages) { return _packages[name]; } return null; } function Has(name, tag) => Get(name, tag) != null; function Get(name, tag) { if(name in _packages) { const package = _packages[name]; if(tag in package.Tags) { return package.Tags[tag]; } } return null; } function Remove(name, tag) { if(name in _packages) { const package = _packages[name]; if(tag in package.Tags) { package.Tags.RemoveKey(tag); if(package.Tags.Keys.Length == 0) { _packages.RemoveKey(name); } } } SavePackageFile(_packages); } function Add(name, type, tag, origin, dependentOf, dependencies) { const existing = Get(name, tag); if(type == "Library" && existing != null) { foreach(dependent in dependentOf) { if(existing.DependentOf.All(x => x.Name != dependent.Name && x.Tag != dependent.Tag)) { existing.DependentOf.Add(dependent); } } SavePackageFile(_packages); return; } if(type != "Library" || !(name in _packages)) { _packages[name] = {Tags: {}, Type: type}; } _packages[name].Tags[tag] = {Origin: origin, DependentOf: dependentOf, Dependencies: dependencies}; SavePackageFile(_packages); } } function GetPackageInstallPath(packageType, packageName, packageTag) { if(packageType == "App") { return IO.Path.Combine(Json.Settings.Subsystems.Run.AppDirectory, $"{packageName}.bs"); } if(packageType == "Library") { return IO.Path.Combine(Json.Settings.Subsystems.Run.LibraryDirectory, $"{packageName}@{packageTag}.bs"); } throw $"Unknown Package Type: {packageType}"; } Config.Packages = new PackageList(LoadPackageFile()); Config.Origins = new OriginList(LoadOriginsFile()); Config.GetPackageInstallPath = GetPackageInstallPath; }(); const Commands; function() { class ConsoleCommand { const _name; const _help; const _func; function ConsoleCommand(name, func, help?) { _name = name; _func = func; _help = help ?? "No Help Text provided."; } function GetHelp() => _help; function GetName() => _name; function Invoke(args) => _func(args); } class ConsoleCommandList { const _list = []; function Has(name) => Get(name) != null; function Get(name) => _list.FirstOrDefault(x => x.GetName() == name); function Add(name, func, help?) { if(Has(name)) { throw $"A command with the name {name} already exists"; } _list.Add(new ConsoleCommand(name, func, help)); } function WriteHelp(name?) { let cmds = _list; if(name != null) { cmds = _list.Where(x=>x.GetName().StartsWith(name)).ToArray(); } if(cmds.Length == 0) { Console.WriteLine("No Commands found!"); } foreach(cmd in cmds) { Console.WriteLine($"{cmd.GetName()} : {cmd.GetHelp()}"); } } } Commands = new ConsoleCommandList(); }();function() { function InstallPackageLocal(package, originName, origin) { const packageName = $"{package.Name}@{package.Tag}"; const sourcePath = IO.Path.Combine(origin.Url, "data", $"{packageName}.bs"); if(!IO.File.Exists(sourcePath)) { throw $"Package '{packageName}' could not be found"; } const destinationPath = Config.GetPackageInstallPath(package.Type, package.Name, package.Tag); Config.Packages.Add(package.Name, package.Type, package.Tag, originName, package.DependentOf, package.Dependencies); if(IO.File.Exists(destinationPath) && package.Type == "Library") { Console.WriteLine($"Package '{destinationPath}' already exists"); return; } Console.WriteLine($"Installing {package.Type} {packageName}"); IO.File.Copy(sourcePath, destinationPath); } function InstallPackageRemote(package, originName, origin) { const packageName = $"{package.Name}@{package.Tag}"; const sourcePath = origin.Url + "/data/" + $"{packageName}.bs"; Console.WriteLine($"Downloading Package: {sourcePath}"); const response = await Net.Get(sourcePath); const content = await response.Content.ReadAsString(); const destinationPath = Config.GetPackageInstallPath(package.Type, package.Name, package.Tag); Config.Packages.Add(package.Name, package.Type, package.Tag, originName, package.DependentOf, package.Dependencies); if(IO.File.Exists(destinationPath) && package.Type == "Library") { Console.WriteLine($"Package '{destinationPath}' already exists"); return; } IO.File.WriteAllText(destinationPath, content); } function LinkPackageLatest(type, name, tag) { Console.WriteLine($"{type} {name}@{tag}"); const sourcePath = Config.GetPackageInstallPath(type, name, tag); if(!IO.File.Exists(sourcePath)) { throw $"Can not link package {name}@{tag} => {name}@latest. File does not exist"; } const destinationPath = Config.GetPackageInstallPath(type, name, "latest"); Console.WriteLine($"Linking {name} 'latest' => '{tag}'"); IO.File.Copy(sourcePath, destinationPath); } function InstallPackage(package, originName, origin) { if(origin.Type == "local") { InstallPackageLocal(package, originName, origin); } else if(origin.Type == "remote") { InstallPackageRemote(package, originName, origin); } else { throw $"Unknown Origin Type: {origin.Type}"; } if(package.Type == "Library") { if("IsLatest" in package) { if(package.IsLatest) { LinkPackageLatest(package.Type, package.Name, package.Tag); } } } } function ProcessInstallList(installList, originName, origin) { foreach(package in installList) { InstallPackage(package, originName, origin); } } function InnerAddPackage(name, tag) { let package = Config.Packages.GetAll(name); Console.WriteLine("Adding Package {name} {tag}: " + package); if(package != null && package.Type == "App") { foreach(t in package.Tags.Keys) { if(tag != t) { PackageApi.Remove(name, t); } } } const ctx = Config.Origins.CreateSearchContext(name); if(ctx == null) { Console.WriteLine($"Could not find Package with name {name}."); return; } const installList = ctx.BuildInstallList(name, tag); const originName = ctx.GetOrigin(); const origin = Config.Origins.Get(originName); ProcessInstallList(installList, originName, origin); package = Config.Packages.GetAll(name); Console.WriteLine($"{package.Type} {name} {tag}"); if(tag == "latest" && package.Type == "Library") { const p = ctx.Get(name); Console.WriteLine(p); LinkPackageLatest(package.Type, name, ctx.ResolveTag(p, tag)); } } function AddPackage(args) { if(args.Length < 1 || args.Length > 2) { Console.WriteLine("Invalid Argument Count. Expected pm add package <name> [<tag>]"); return; } const name = args[0]; let tag = "latest"; if(args.Length == 2) { tag = args[1]; } InnerAddPackage(name, tag); } function AddOrigin(args) { if(args.Length != 2) { Console.WriteLine("Invalid Argument Count. Expected pm add origin <name> <url>"); return; } const name = args[0]; let url = args[1]; const type; if(url.StartsWith("http://") || url.StartsWith("https://")) { type = "remote"; } else { type = "local"; url = IO.Path.GetFullPath(url); } Config.Origins.Add(name, url, type); } function Add(args) { if(args.Length == 0) { Console.WriteLine("Invalid Argument Count. Expected 'package' or 'origin' as argument"); return; } const type = args[0]; if(type == "package") { AddPackage(args.Skip(1).ToArray()); } else if(type == "origin") { AddOrigin(args.Skip(1).ToArray()); } else { Console.WriteLine($"Invalid Argument. Expected 'package' or 'origin' as argument but got '{type}'"); return; } } Commands.Add("add", Add, "Adds Packages or Origins"); PackageApi.Add = InnerAddPackage; }();function() { function Help(args) { const name = args.Length == 0 ? null : args[0]; Commands.WriteHelp(name); } Commands.Add("help", Help, "Displays this help text"); }();function() { function List(args) { if(args.Length == 0) { Console.WriteLine("Invalid Argument Count. Expected 'packages' or 'origins' as argument"); return; } const type = args[0]; if(type == "packages") { const packages = Config.Packages.GetPackages(); foreach(package in packages.Keys) { const p = packages[package]; foreach(tag in p.Tags.Keys) { const t = p.Tags[tag]; Console.WriteLine($"{p.Type} {package}@{tag} installed from {t.Origin}"); } } } else if(type == "origins") { const origins = Config.Origins.GetOrigins(); foreach(origin in origins.Keys) { Console.WriteLine($"{origins[origin].Type} {origin}: {origins[origin].Url}"); } } else { Console.WriteLine($"Invalid Argument. Expected 'packages' or 'origins' as argument but got '{type}'"); return; } } Commands.Add("list", List, "Lists Installed Packages or Origins"); }(); function() { function ResolveTag(packages, name, tag) { if(name in packages) { const package = packages[name]; while(Runtime.Native.IsString(package.Tags[tag])) { tag = package.Tags[tag]; } return tag; } return null; } function Publish(args) { if(args.Length < 5) { Console.WriteLine("Expected arguments type origin name tag sourceFile [<dep[@tag]>]"); return; } const origin = Config.Origins.Get(args[1]); if(origin == null) { throw $"Origin {args[1]} not found"; } if(origin.Type == "remote") { throw $"Publishing to a remote origin is not supported!"; } const packagePath = IO.Path.Combine(origin.Url, "packages.json"); if(!IO.File.Exists(packagePath)) { throw $"Package File '{packagePath}' does not exist!"; } const packageListing = Json.FromJson(IO.File.ReadAllText(packagePath)); const packageType = args[0]; const name = args[2]; const tag = args[3]; const file = args[4]; if(!IO.File.Exists(file)) { throw $"File '{file}' does not exist."; } const package; if(name in packageListing) { package = packageListing[name]; } else { package = { Type: packageType, Tags: {} }; packageListing[name] = package; } if(tag == "latest") { throw "Can not publish to tag 'latest' directly. It will be updated automatically"; } const tagObj; if(tag in package.Tags) { throw $"Tag {tag} does already exist!"; } else { tagObj = {}; package.Tags[tag] = tagObj; } const dependencies = args.Skip(5).ToArray(); if(dependencies.Length != 0) { tagObj.Dependencies = []; foreach(dependency in dependencies) { const depName; const depTag; if(dependency.Contains("@")) { const parts = dependency.Split("@"); depName = parts[0]; depTag = parts[1]; } else { depName = dependency; depTag = "latest"; } tagObj.Dependencies.Add({Name: depName, Tag: depTag}); } } package.Tags.latest = tag; IO.File.WriteAllText(packagePath, Json.ToJson(packageListing)); const dataPath = IO.Path.Combine(origin.Url, "data"); if(!IO.Directory.Exists(dataPath)) { IO.Directory.CreateDirectory(dataPath); } const dstPath = IO.Path.Combine(dataPath, $"{name}@{tag}.bs"); IO.File.Copy(file, dstPath); } Commands.Add("publish", Publish, "Publishes a Package to an Origin"); }(); function() { function RemoveFromDependents(package, name, tag) { package.DependentOf = package.DependentOf.Where(x=>x.Name != name && x.Tag != tag).ToArray(); Config.Packages.Save(); } function InnerRemovePackage(name, tag) { const package = Config.Packages.Get(name, tag); if(package.DependentOf.Length != 0) { Console.WriteLine($"Can not remove package: {name}@{tag} because it is a dependency of:"); foreach(dep in package.DependentOf) { Console.WriteLine($"\t- {dep.Name}@{dep.Tag}"); } return; } foreach(dep in package.Dependencies) { const depPackage = Config.Packages.Get(dep.Name, dep.Tag); RemoveFromDependents(depPackage, name, tag); if(depPackage.DependentOf.Length == 0) { InnerRemovePackage(dep.Name, dep.Tag); } } Console.WriteLine($"Removing Package {name}@{tag}"); IO.File.Delete(Config.GetPackageInstallPath(Config.Packages.GetAll(name).Type, name, tag)); Config.Packages.Remove(name, tag); } function RemovePackage(args) { foreach(package in args) { if(package.Contains("@")) { const parts = package.Split("@"); InnerRemovePackage(parts[0], parts[1]); } else { const p = Config.Packages.GetAll(package); if(p == null) { Console.WriteLine($"Package with name '{package}' could not be found!"); } else { foreach(tag in p.Tags.Keys) { InnerRemovePackage(package, tag); } } } } } function RemoveOrigin(args) { if(args.Length != 1) { Console.WriteLine("Invalid Argument Count. Expected pm remove origin <name>"); } const name = args[0]; Config.Origins.Remove(name); } function Remove(args) { if(args.Length == 0) { Console.WriteLine("Invalid Argument Count. Expected 'package' or 'origin' as argument"); return; } const type = args[0]; if(type == "package") { RemovePackage(args.Skip(1).ToArray()); } else if(type == "origin") { RemoveOrigin(args.Skip(1).ToArray()); } else { Console.WriteLine($"Invalid Argument. Expected 'package' or 'origin' as argument but got '{type}'"); return; } } Commands.Add("remove", Remove, "Removes Packages or Origins"); PackageApi.Remove = InnerRemovePackage; }();function() { function UpdateOriginLocal(name, origin) { Console.WriteLine($"Updating Origin: {origin.Type} {name}: {origin.Url}"); const packagePath = IO.Path.Combine(origin.Url, "packages.json"); const localPackagePath = Config.Origins.GetPackageListPath(name); if(!IO.File.Exists(packagePath)) { throw $"Could not Update Origin {name}: Package File does not exist."; } if(IO.File.Exists(localPackagePath)) { IO.File.Delete(localPackagePath); } IO.File.Copy(packagePath, localPackagePath); } function UpdateOriginRemote(name, origin) { Console.WriteLine($"Updating Origin: {origin.Type} {name}: {origin.Url}"); const localPackagePath = Config.Origins.GetPackageListPath(name); const packagePath = $"{origin.Url}/packages.json"; const response = await Net.Get(packagePath); const content = await response.Content.ReadAsString(); if(IO.File.Exists(localPackagePath)) { IO.File.Delete(localPackagePath); } IO.File.WriteAllText(localPackagePath, content); } function UpdateOrigin(name, origin) { if(origin.Type == "local") { UpdateOriginLocal(name, origin); } else if(origin.Type == "remote") { UpdateOriginRemote(name, origin); } else { throw $"Unknown Origin Type: {origin.Type}"; } } function Update(args) { if(args.Length != 0) { foreach(originName in args) { const origin = Config.Origins.Get(originName); if(origin == null) { throw $"Origin with name {originName} does not exist"; } UpdateOrigin(originName, origin); } } else { const origins = Config.Origins.GetOrigins(); foreach(originName in origins.Keys) { UpdateOrigin(originName, origins[originName]); } } } Commands.Add("update", Update, "Fetches the Package Listing from the origins"); }(); function() { function Upgrade(args) { const packages = Config.Packages.GetPackages(); foreach(name in packages.Keys) { const package = packages[name]; if(package.Type == "App") { PackageApi.Add(name, "latest"); } } } Commands.Add("upgrade", Upgrade, "Upgrades Installed Apps"); }();function() { function Version(args) { Console.WriteLine("PackageManager@2023.7.22.0"); } Commands.Add("version", Version, "Displays the current Package Manager Version"); }(); function() { const args = Runtime.GetArguments(); if(args.Length == 0) { Commands.WriteHelp(); return; } const commandName = args[0]; const command = Commands.Get(commandName); if(command == null) { Commands.WriteHelp(commandName); return; } args.RemoveAt(0); command.Invoke(args); }();