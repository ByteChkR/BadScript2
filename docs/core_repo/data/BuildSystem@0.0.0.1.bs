class BuildLogger { const Tag; function BuildLogger(tag!) { Tag = tag; } function Log(msg!) { Console.WriteLine($"[{Tag}:LOG] {msg}"); } function Warn(msg!) { Console.WriteLine($"[{Tag}:WARN] {msg}"); } function Error(msg!) { Console.WriteLine($"[{Tag}:ERR] {msg}"); } } class BuildTargetResolver { const _Funcs = []; function AddResolverFunc(Function func!) { _Funcs.Add(func); } function Resolve(string name!) { foreach(func in _Funcs) { const target = func(name); if(target != null) { return target; } } throw $"Can not find target: '{name}'"; } } class BuildTargetLoader { function ResolveString(Table context!, string str) { if(str.Contains("{") && str.Contains("}")) { const scope = new Scope("ResolveStringCtx", context); return await Runtime.EvaluateAsync($"$\"{str}\"", "", false, scope); } return str; } function ResolveTable(Table context!, Table table) { const t = {} foreach(key in table.Keys) { t[Resolve(context, key)] = Resolve(context, table[key]); } return t; } function ResolveArray(Table context!, Array array) { for(let i = 0; i < array.Length; i++) { array[i] = Resolve(context, array[i]); } return array; } function Resolve(Table context!, obj) { if(obj == null) { return obj; } if(Runtime.Native.IsTable(obj)) { return ResolveTable(context, obj); } else if(Runtime.Native.IsArray(obj)) { return ResolveArray(context, obj); } else if(Runtime.Native.IsString(obj)) { return ResolveString(context, obj); } return obj; } function Load(string file!, context) { return Resolve(context, Json.FromJson(IO.File.ReadAllText(file))); } } class BuildTargetDirectoryResolver { const Path; const Targets = []; function BuildTargetDirectoryResolver(string path!, context) { Path = path; LoadTargets(context); } function LoadTargets(context) { Targets.Clear(); foreach(file in IO.Directory.GetFiles(Path, "json", false)) { const loader = new BuildTargetLoader(); const target = new BuildTarget(loader.Load(file, context)); if(target.Info.Keys.Contains("Script")) { target.Info.Script = target.Info.Script.Replace("$"+"(DEFAULT_TARGETSCRIPT_PATH)", IO.Path.Combine(IO.Directory.GetStartupDirectory(), "data", "subsystems", "build", "scripts")); target.Info.Script = target.Info.Script.Replace("$"+"(DEFAULT_TARGET_PATH)", IO.Path.Combine(IO.Directory.GetStartupDirectory(), "data", "subsystems", "build", "targets")); } Targets.Add(target); } } function Resolve(string name!) { return Targets.FirstOrDefault(function(t) => t.GetName() == name); } } function CreateDebugString(string content) { const cLen = content.Length; const targetLen = 60; if(cLen > targetLen) { return content; } const padding = targetLen - cLen; const leftPad = Math.Ceiling(padding/2); const rightPad = Math.Floor(padding/2); let r = ""; for(let i = 0; i < leftPad; i++) { r += "-"; } r += content; for(let i = 0; i < rightPad; i++) { r += "-"; } return r; } class BuildTarget { const Info; const Logger; function BuildTarget(info!) { Info = info; Logger = new BuildLogger("Target"); } function GetName() { return Info.Name; } function GetDependencies() { if(Info.Keys.Contains("Dependencies")) { return Info.Dependencies; } return []; } function GetScript() { if(Info.Keys.Contains("Script")) { return Info.Script; } return null; } function GetPreScript() { if(Info.Keys.Contains("PreScript")) { return Info.PreScript; } return null; } function GetDescription() { if(Info.Keys.Contains("Description")) { return Info.Description; } return GetName(); } function Save(string file!) { IO.File.WriteAllText(file, Json.ToJson(Info)); } function ExecuteScript(scriptPath, context) { if(scriptPath == null) { return; } const scope = Runtime.CreateDefaultScope(); scope.GetLocals()["Context"] = context; await Runtime.EvaluateAsync(IO.File.ReadAllText(scriptPath), scriptPath, false, scope); } function RunPreScript(context) { ExecuteScript(GetPreScript(), context); } function RunScript(context) { ExecuteScript(GetScript(), context); } function Run(BuildSystem system!, context) { Logger.Log(CreateDebugString($" START TARGET '{Info.Name}' ")); RunPreScript(context); foreach(dep in GetDependencies()) { system.Run(dep, context); } RunScript(context); Logger.Log(CreateDebugString($" END TARGET '{Info.Name}' ")); } } class BuildSystem { function AddTargetSource(string dir!, context) { if(!IO.Directory.Exists(dir)) { return; } const dirResolver = new BuildTargetDirectoryResolver(dir, context); Resolver.AddResolverFunc(dirResolver.Resolve); } const Targets = []; const Resolver = new BuildTargetResolver(); function Run(string name!, context) { GetTarget(name).Run(this, context); } function GetTarget(string name!) { let target = Targets.FirstOrDefault(function(t) => t.GetName() == name); if(target == null) { target = Resolver.Resolve(name); Targets.Add(target); } return target; } } Runtime.Export("BuildSystem", { BuildSystem: BuildSystem, BuildLogger: BuildLogger, BuildTarget: BuildTarget, BuildTargetDirectoryResolver: BuildTargetDirectoryResolver, BuildTargetLoader: BuildTargetLoader, BuildTargetResolver: BuildTargetResolver });