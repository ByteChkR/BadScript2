class CommandlineArgument { const string Name; const string Short; const string Description; const bool Required; const bool IsFlag; const bool AllowMultiple; function CommandlineArgument(string name!, string short?, bool required?, string description?, bool isFlag?, bool allowMultiple?) { Name = name; Short = short; Required = required ?? false; Description = description ?? ""; IsFlag = isFlag ?? false; AllowMultiple = allowMultiple ?? true; } } class CommandlineParserResult { const Table _parsed; const Table _flags; const Array _unparsed; const Table _aliases; function CommandlineParserResult(Table parsed!, Table flags!, Table aliases!, Array unparsed!) { _parsed = parsed; _flags = flags; _aliases = aliases; _unparsed = unparsed; } function string ResolveAlias(string name!) { if(name in _aliases) { return _aliases[name]; } return name; } function bool HasUnparsed() { return _unparsed.Length != 0; } function Array GetUnparsed() { return _unparsed; } function bool HasFlag(string name!) { const string n = ResolveAlias(name); if(n in _flags) { return _flags[n] == true; } return false; } function bool HasValue(string name!) { const string n = ResolveAlias(name); if(n in _parsed) { const v = _parsed[n]; if(Runtime.Native.IsArray(v)) { return v.Length != 0; } return true; } return false; } function string GetValue(string name!) { const string n = ResolveAlias(name); if(n in _parsed) { const v = _parsed[n]; if(!Runtime.Native.IsArray(v)) { return v; } if(v.Length != 0) { return v[0]; } } return ""; } function Array GetValues(string name!) { const string n = ResolveAlias(name); if(n in _parsed) { const v = _parsed[n]; if(Runtime.Native.IsArray(v)) { return v; } return [v]; } return []; } } function CommandlineArgument GetArgObjectByShort(Array arguments!, string name!) { for(let num i = 0; i < arguments.Length; i++) { const CommandlineArgument arg = arguments[i]; if(arg.Short == name) { return arg; } } return null; } function CommandlineArgument GetArgObject(Array arguments!, string name!) { for(let num i = 0; i < arguments.Length; i++) { const CommandlineArgument arg = arguments[i]; if(arg.Name == name) { return arg; } } return null; } function Table GetFlagTable(Array arguments!) { const r = {} for(let num i = 0; i < arguments.Length; i++) { const CommandlineArgument arg = arguments[i]; if(arg.IsFlag) { r[arg.Name] = false; } } return r; } function Table GetAliases(Array arguments!) { const r = {} foreach(arg in arguments) { if(arg.Short != null) { r[arg.Short] = arg.Name; } } return r; } function Table ParseValues(Array args!, Array arguments!) { const Table result = {} for(let num i = 0; i < args.Length - 1; i++) { const string arg = args[i]; const CommandlineArgument argument; if(arg.StartsWith("--")) { argument = GetArgObject(arguments, arg.Remove(0, 2)); } else if(arg.StartsWith("-")) { argument = GetArgObjectByShort(arguments, arg.Remove(0, 1)); } else { continue; } if(argument.AllowMultiple) { if(!(argument.Name in result)) { result[argument.Name] = []; } let num newArgCount = 0; for(let num j = i + 1; j < args.Length && !args[j].StartsWith("-"); j++) { result[argument.Name].Add(args[j]); newArgCount++; } if(newArgCount == 0) { throw $"Expected at least one argument for {argument.Name}"; } args.RemoveAt(i); while(newArgCount != 0) { args.RemoveAt(i); newArgCount--; } } else { args.RemoveAt(i); if(argument.Name in result) { throw $"A value for {argument.Name} already exists!"; } result[argument.Name] = args[i]; args.RemoveAt(i); } i--; } return result; } function Table ParseFlags(Array args!, Array arguments!) { const Table result = GetFlagTable(arguments); for (let num i = args.Length - 1; i >= 0; i--) { const string arg = args[i]; const CommandlineArgument argument; if(arg.StartsWith("--")) { argument = GetArgObject(arguments, arg.Remove(0, 2)); } else if(arg.StartsWith("-")) { argument = GetArgObjectByShort(arguments, arg.Remove(0, 1)); } else { continue; } if(argument.Name in result) { result[argument.Name] = true; args.RemoveAt(i); } } return result; } function CheckRequiredValues(Table values!, Array arguments!) { for (let num i = 0; i < arguments.Length; i++) { const CommandlineArgument arg = arguments[i]; if(arg.Required && !(arg.Name in values)) { throw $"Missing Required Value {arg.Name}"; } } } class CommandlineParser { const Array _arguments = []; const bool _allowUnparsed; function CommandlineParser(bool allowUnparsed?) { _allowUnparsed = allowUnparsed ?? true; } function bool ArgumentNameExists(string name!) { for (let i = 0; i < _arguments.Length; i++) { const arg = _arguments[i]; if(arg.Name == name) { return true; } } return false; } function bool ArgumentShortExists(string name!) { for (let i = 0; i < _arguments.Length; i++) { const arg = _arguments[i]; if(arg.Short == name) { return true; } } return false; } function bool ArgumentExists(string name!) { return ArgumentNameExists(name) || ArgumentShortExists(name); } function Flag(string name!, string short?, string description?) { if(ArgumentNameExists(name) || (short != null && ArgumentShortExists(short))) { throw "Argument with name {name} already exists!"; } _arguments.Add(new CommandlineArgument(name, short, false, description, true, false)); return this; } function Value(string name!, string short?, bool required?, string description?, bool allowMultiple?) { if(ArgumentNameExists(name) || (short != null && ArgumentShortExists(short))) { throw "Argument with name {name} already exists!"; } _arguments.Add(new CommandlineArgument(name, short, required, description, false, allowMultiple)); return this; } function CommandlineParserResult Parse(Array args) { const Table flags = ParseFlags(args, _arguments); const Table parsed = ParseValues(args, _arguments); const Table aliases = GetAliases(_arguments); const Array unparsed = args; if(!_allowUnparsed && unparsed.Length != 0) { throw $"Parse Error. There are unparsed values: {unparsed.ToString()}"; } CheckRequiredValues(parsed, _arguments); return new CommandlineParserResult(parsed, flags, aliases, unparsed); } function CommandlineParserResult ParseFromString(string args!) { return Parse(args.Split(" ", true)); } function GetHelpText() { let string r = "Arguments:\n"; for (let num i = 0; i < _arguments.Length; i++) { const arg = _arguments[i]; r += $"\t{arg.Required ? "Required " : ""}{arg.IsFlag ? "Flag" : "Value"} --{arg.Name}{arg.Short != null ? $"/-{arg.Short}" : ""} : {arg.Description}\n"; } return r; } } Runtime.Export("CommandlineParser", CommandlineParser);