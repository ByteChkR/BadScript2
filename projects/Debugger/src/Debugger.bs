
const files = [];
let stepMode = true;
const commands = {}
const breakPoints = [];

class DebuggerCommand
{
	const _func;
	const _helpText;
	function DebuggerCommand(func, helpText)
	{
		_func = func;
		_helpText = helpText;
	}

	function Invoke(step, cmd)
	{
		return _func(step, cmd);
	}

	function GetHelp()
	{
		return _helpText;
	}
}

class BreakPoint
{
	let File;
	let Line;
	let Condition;
	function IsBreakPoint(step)
	{
		return step.Position.FileName == File &&
				step.Line.ToString() == Line &&
				step.Evaluate(Condition);
	}

	function BreakPoint(file, line, condition?)
	{
		File = file;
		Line = line;
		Condition = condition ?? "true";
	}
}

function ExecuteCommand(step, name, cmd)
{
	commands[name].Invoke(step, cmd);
}

function FindCommand(cmd)
{
	if(cmd == null)
	{
		return null;
	}
	foreach(key in commands.Keys)
	{
		if(cmd.StartsWith(key))
		{
			return key;
		}
	}
	return null;
}

function DebugStepCommandline(step)
{
	let string cmd;
	while(cmd != "")
	{
		Console.Write("DBG>");
		cmd = Console.ReadLine();
		if(cmd != "")
		{
			const command = FindCommand(cmd);
			if(command == null)
			{
				Console.WriteLine($"Can not find command '{cmd}'");
				Help(step, cmd);
			}
			else
			{
				ExecuteCommand(step, command, cmd);
			}
		}
	}
}

function DisplayLoadFileDialog(file)
{
	Console.WriteLine($"Loading File: {file}");
	Console.Write("Do you want to load it into the debugger? [y/N]: ");
	let cmd = Console.ReadLine().ToUpper();
	if(cmd == "Y")
	{
		files.Add(file);
	}
}


function IsBreakPoint(step)
{
	for (let i = 0; i < breakPoints.Length; i++) 
	{
		const bp = breakPoints[i];
		if(bp.IsBreakPoint(step))
		{
			return true;
		}	
	}
	return false;
}


function ToggleStep(step, cmd)
{
	stepMode = !stepMode;
	Console.WriteLine($"Step Mode: {stepMode}")
}

function UnsetBreakPoint(step, cmd)
{
	const parts = cmd.Remove(0, "sbp".Length).Split(" ", true);
	if(parts.Length != 2)
	{
		Console.WriteLine($"Invalid Arguments '{cmd}'");
		return;
	}
	let file = parts[0];
	let line = parts[1];

	for(let i = breakPoints.Length - 1; i >= 0; i--)
	{
		if(breakPoints[i].File == file &&
			breakPoints[i].Line == line)
		{
			breakPoints.RemoveAt(i);
			Console.WriteLine("Removing Breakpoint");
		}
	}
}

function SetBreakPoint(step, cmd)
{
	const parts = cmd.Remove(0, "sbp".Length).Split(" ", true);
	
	let file;
	let line;
	let condition;
	if(parts.Length == 0)
	{
		file = step.Position.FileName;
		line = step.Line.ToString();
		condition = null;
	}
	else if(parts.Length == 1)
	{
		file = step.Position.FileName;
		line = parts[0];
		condition = null;
	}
	else if(parts.Length == 2)
	{
		file = parts[0];
		line = parts[1];
		condition = null;
	}
	else
	{
		file = parts[0];
		line = parts[1];
		condition = parts[2];
		for(let i = 3; i < parts.Length; i++)
		{
			condition += " " + parts[i];
		}
	}

	Console.WriteLine($"Adding Breakpoint {file} : {line} with condition '{condition}'");
	breakPoints.Add(new BreakPoint(file, line, condition));
}

function Help(step, cmd)
{
	let s = "Help:\n";
	foreach(key in commands.Keys)
	{
		s += $"\t{key}: {commands[key].GetHelp()}\n";
	}

	Console.WriteLine(s);
}

function ViewSource(step, cmd)
{
	Console.WriteLine(step.SourceView);
}

function ListBreakPoints(step, cmd)
{
	foreach(bp in breakPoints)
	{
		Console.WriteLine($"{bp.File} : {bp.Line} with condition '{bp.Condition}'");
	}
}

function EvaluateInStep(step, cmd)
{
	let src = cmd.Remove(0, "eval".Length);
	Console.WriteLine($"Return: {step.Evaluate(src)}");
}

commands["help"] = new DebuggerCommand(Help, "Displays this help text.");
commands["step"] = new DebuggerCommand(ToggleStep, "Toggles the Step Mode");
commands["sbp"] = new DebuggerCommand(SetBreakPoint, "Sets a breakpoint. Usage: sbp [<line> | <file> <line> | <file> <line> <condition>]");
commands["ubp"] = new DebuggerCommand(UnsetBreakPoint, "Unsets a breakpoint. Usage: ubp <file> <line>");
commands["lbp"] = new DebuggerCommand(ListBreakPoints, "Lists all Breakpoints.");
commands["view"] = new DebuggerCommand(ViewSource, "Displays the Source Code with the current position of execution.");
commands["eval"] = new DebuggerCommand(EvaluateInStep, "Evaluates the specified expression. Usage: eval <expr>");

function OnLoadFile(file)
{
	if(!files.Contains(file) && file != Debugger.DebuggerPath.Replace("\\", "/"))
	{
		DisplayLoadFileDialog(file);
	}	
}


function OnStep(step)
{
	if(files.Contains(step.Position.FileName))
	{
		if(stepMode || IsBreakPoint(step))
		{
			Console.WriteLine(step.SourceView);
			DebugStepCommandline(step);
		}
	}
}

Debugger.RegisterStep(OnStep);
Debugger.RegisterOnFileLoaded(OnLoadFile);

